
参考链接:

* [https://developer.aliyun.com/article/981881](https://developer.aliyun.com/article/981881)
* [https://www.infoq.cn/article/XUJL32hTDKYqAKz0hkMM](https://www.infoq.cn/article/XUJL32hTDKYqAKz0hkMM)
* [https://cloud.tencent.com/developer/article/1785902](https://cloud.tencent.com/developer/article/1785902)

### 有损压缩

XCode构建时会做“compile asset catalog”，会重新对图片进行无损压缩。因此使用imageoptim等工具进行无损压缩效果不明显，其中压缩png图片没有效果，压缩jpg图片有一定效果。根据实践经验，icon做有损压缩并不影响视觉体验，压缩率可以达到70%~80%。比如使用tinypng算法压缩一张425.9 KB的png图片，压缩后79.8 KB，压缩率达到81%。

TOP中通过hook pre commit 对AM(添加,修改)的图片进行自动压缩.使用tinypng命令行工具,预备10几个key.

### 编译优化

#### 精简编译产物Oz：Optimization Level

* XCode会优化连续的汇编指令，从而减少二进制大小，但副作用是执行速度会变慢

```
主工程Release
Optimization Level :-Oz

Framework工程
Optimization Level :-Oz

pod的项目配置参考主项目中的项目文件中的写法
config.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Osize'
config.build_settings['GCC_OPTIMIZATION_LEVEL'] = 'z'
```

#### LTO（OC/C++）

* LTO 是在LLVM链接时，优化跨模块调用代码
* 将一些函数內联化
* 去除了一些无用代码
* 对程序有全局的优化作用
* 降低编译链接速度，只建议在打正式包时开启

```
主工程Release
Link-Time Optimization 设置为Incremental

framework工程Release
Link-Time Optimization 设置为Incremental
```

#### 动态库复用主二进制静态库

C++动态库经常用到一些基础库比如openssl、libyuv、libcurl，他们一般是静态库。如果动态库引用了静态库，它编译时默认会内嵌静态库的所有符号。虽然我们可以在动态库中设置只导出需要用到的静态库符号，但是有可能多个动态库都用到了同一个基础库，这样还是会造成基础库的冗余。比如openssl大小1MB，如果A、B两个动态库依赖了openssl，APP也引用了openssl，最终ipa包实际有3个openssl，有2MB大小是冗余的

这种场景下，最佳解决方案是共享符号表，让动态库可以调用主二进制的基础库符号，从而可以去掉内置的静态库。只要修改XCode的Link配置，无需额外的代码开发。


#### 剥离符号表：Strip Linked Product

* 静态库不能将Strip Style 设置为All Symbols，因为剥离了所有符号的静态库是无法被正常链接的
* 去除符号不影响 dSYM 文件中的符号信息，查看崩溃日志时，可以从 dSYM 文件中找对应符号

```
主工程Release
Deployment Postprocessing :YES
Strip Linked Product :YES
Strip Style :All Symbols（剥离所有符号表和重定向信息）

Framework工程
Deployment Postprocessing :YES
Strip Linked Product :YES
Strip Style :Non-Global Symbols（剥离包括调试信息等非全局的符号，保留外部符号）
```

#### 链接器产物压缩（黑科技）

iOS工程构建产物是MachO文件，MachO文件中的TEXT段存放了各种只读的数据段，__cstring段存放了普通的C String，__objc_methtype和__objc_methname存放了Objc的方法签名和方法名。比入Objc代码中声明的@"Hello world"，底层会产生一个CFString，构建后存放在__cstring中。这些数据很占空间，一般工程至少会有10MB以上，压缩的收益很可观。我们上线后，App Store安装包大小从191MB优化到174MB，减少了16MB。

技术原理：

链接时将TEXT段数据移到__DATA段并压缩，运行时先执行解压代码，解压TEXT段数据存到自定义段中，将代码中对字符串的引用的地址修正为解压后的自定义段。

苹果在 iOS 13 已经对下载大小做了优化，所以本方案无法再对 iOS 13 的设备的下载大小进一步优化。

即，若用户的设备 < iOS 13，那么本方案可以减少该设备上 App 32~34%的下载大小；

若用户的设备 >= iOS 13，本方案不会对该设备的 App 的下载大小有进一步优化，也不会有负面影响。

因此，如果你看到 App Store Connect 后台展示的下载大小从 iPhone 11 开始大幅减小，不要惊讶，这是因为 iPhone 11 开始默认搭载的是 iOS 13+ 的系统。

目前推测苹果在 iOS 13 也是在针对压缩做了优化，可能是移除了加密或者是先压缩后加密。

间参考文章 2,3

对项目工程进行 Archive 后会生成 .xcarchive 文件，该文件中包含了 App、dsYMS 以及其它信息。如图所示为 .xcarchive 文件中包含的内容：

将 .xcarchive 文件上传到 App Store Connect 后，苹果会对 App 中的可执行文件进行 DRM 加密，然后将 App 压缩成 ipa 文件，才发布到 App Store。加密对可执行文件的大小本身影响很小（对今日头条 App 的影响为 2 MB），但是它会严重影响可执行文件的压缩效率，导致压缩后的 ipa 大小增加，也就是下载大小增大。

实际上，这种加密几乎没有用，只要有越狱手机，使用市面上的脱壳工具就可以很容易地进行解密。

如果使用 xcconfig 来管理构建参数的，如果你也使用该方式，那么使用下面这一行代码就能完成配置：

```
APP_THIN_LINK_FLAGS = -Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab,-rename_section,__TEXT,__const,__RODATA,__const,-rename_section,__TEXT,__text,__BD_TEXT,__text,-rename_section,__TEXT,__textcoal_nt,__BD_TEXT,__text,-rename_section,__TEXT,__StaticInit,__BD_TEXT,__text,-rename_section,__TEXT,__stubs,__BD_TEXT,__stubs,-rename_section,__TEXT,__picsymbolstub4,__BD_TEXT,__picsymbolstub4,-segprot,__BD_TEXT,rx,rx
```

如果你是没有使用这种方式，在Other Linker Flags中逐行添加以下配置即可：

```c
-Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring
-Wl,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname
-Wl,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname
-Wl,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype
-Wl,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab
-Wl,-rename_section,__TEXT,__const,__RODATA,__const
-Wl,-rename_section,__TEXT,__text,__BD_TEXT,__text
-Wl,-rename_section,__TEXT,__textcoal_nt,__BD_TEXT,__text
-Wl,-rename_section,__TEXT,__StaticInit,__BD_TEXT,__text
-Wl,-rename_section,__TEXT,__stubs,__BD_TEXT,__stubs
-Wl,-rename_section,__TEXT,__picsymbolstub4,__BD_TEXT,__picsymbolstub4,
-Wl,-segprot,__BD_TEXT,rx,rx
```

如果你的二进制文件中存在自定义 Section 的话，比如使用了类似attribute((section("__TEXT,__custom_section")))的方式创建了自定义 Section，则可能需要做如下的配置以移走自定义 Section，具体见 「2.3.3 场景三」 的详细分析。

```
APP_THIN_LINK_FLAGS = -Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab,-rename_section,__TEXT,__const,__RODATA,__const,-rename_section,__TEXT,__text,__BD_TEXT,__text,-rename_section,__TEXT,__textcoal_nt,__BD_TEXT,__text,-rename_section,__TEXT,__StaticInit,__BD_TEXT,__text,-rename_section,__TEXT,__stubs,__BD_TEXT,__stubs,-segprot,__BD_TEXT,rx,rx,-rename_section,__TEXT,__picsymbolstub4,__BD_TEXT,__picsymbolstub4,-rename_section,__TEXT, __custom_section,__CUSTOM_TEXT,__text,-segprot, __CUSTOM_TEXT,rx,rx
```

最终链接配置为:

```
-Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring
-Wl,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname
-Wl,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname
-Wl,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype
-Wl,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab
-Wl,-rename_section,__TEXT,__const,__RODATA,__const
-Wl,-segprot,__RODATA,rw,rw
```

注意点: 

* `-Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring`：将 `__TEXT,__cstring`段重命名为` __RODATA,__cstring`。
* `__RODATA `需要设置为读写权限
* 所有的段只能有一个为可执行权限
* 对可执行文件执行`otool -l TopTop | grep -A 10 SEGMENT`可能看出来段的权限

```
cmd LC_SEGMENT_64
cmdsize 72
segname __PAGEZERO
vmaddr 0x0000000000000000
vmsize 0x0000000100000000
fileoff 0
filesize 0
maxprot 0x00000000
initprot 0x00000000
nsects 0
flags 0x0
--
cmd LC_SEGMENT_64
cmdsize 1592
segname __TEXT
vmaddr 0x0000000100000000
vmsize 0x0000000001308000
fileoff 0
filesize 19955712
maxprot 0x00000005
initprot 0x00000005
nsects 19
flags 0x0
--
cmd LC_SEGMENT_64
cmdsize 2152
segname __DATA
vmaddr 0x0000000101308000
vmsize 0x0000000000558000
fileoff 19955712
filesize 5455872
maxprot 0x00000003
initprot 0x00000003
nsects 26
flags 0x0
--
cmd LC_SEGMENT_64
cmdsize 552
segname __RODATA
vmaddr 0x0000000101860000
vmsize 0x000000000025c000
fileoff 25411584
filesize 2473984
maxprot 0x00000003
initprot 0x00000003
nsects 6
flags 0x0
--
cmd LC_SEGMENT_64
cmdsize 72
segname __LINKEDIT
vmaddr 0x0000000101abc000
vmsize 0x0000000000110000
fileoff 27885568
filesize 1100112
maxprot 0x00000001
initprot 0x00000001
nsects 0
flags 0x0
```

看maxprot, maxprot 0x00000005为可执行权限.要确保所有段只有一个为可执行权限

* 这里保留之前的`__TEXT`为可执行权限,将新增的`__RODATA `设置为读写权限
* 如果有多个可执行权限的话,上传到Testfilight后会有审核错误
*