### 目录

* <a href="#layoutSubviews什么时候调用">layoutSubviews什么时候调用</a>
* <a href="#Xcode中的workspace、xcodeproj、target、schema的关系 ">Xcode中的workspace、xcodeproj、target、schema的关系 </a>
* <a href="#malloc和free">malloc和free</a>
* <a href="#静态库.a和.framework">静态库.a和.framework</a>


### 详情



<a id="layoutSubviews什么时候调用"></a>
#### layoutSubviews什么时候调用

```
init初始化不回触发
addSubView会触发
改变view的大小会触发,改变origin不回触发
改变子view的大小会触发,改变子view的origin不回触发
改变bounds会触发
旋转实测没触发(网上说触发),只是控制器self.view触发
```

<a id="Xcode中的workspace、xcodeproj、target、schema的关系 "></a>
#### Xcode中的workspace、xcodeproj、target、schema的关系 

[https://zhuanlan.zhihu.com/p/52130048](https://zhuanlan.zhihu.com/p/52130048)


<a id="malloc和free"></a>
#### malloc和free

* 详细:[https://www.huaweicloud.com/articles/baea6198b9bbe8da4875c09f081edd21.html](https://www.huaweicloud.com/articles/baea6198b9bbe8da4875c09f081edd21.html)
* 申请内存后必须坚持是否分配成功(堆)
* 释放后最后置NULL指针
* 申请后最好强转类型,可以躲过一些编译检查
*  free释放的事指向的内存,指针没有释放,只不过指针指向的内容是未定义的,垃圾内存
*  大多数实现分配的存储空间比要求的要稍微大一些,额外的空间就管理信息(分配块的长度,下一个分配块的指针等待).一般用结构体存储

	```
	 struct mem_control_block { 
	 	int is_available; //一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记
     	int size; //这是实际空间的大小  
     	};
	```

<a id="静态库.a和.framework"></a>
#### 静态库.a和.framework

* 库: 共享代码的方式.一般分为静态库和动态库.
* 静态库: 编译的时候会直接拷贝一份到目标程序里,这段代码在目标程序里就不会改变了.好处没有外部依赖,直接可以运行,缺点增大目标程序体积.有多份冗余拷贝
* 动态库: 链接时不复制.运行时由系统加载到内存,工程序使用.系统只加载一次,多个程序共用.有点不影响目标程序体积.缺点: 性能上的损失,依赖外部环境. 自己开发的静态库还是动态库都要复制到目标程序,所以苹果又把这个交友embeded framework.
* 静态库形式: a.  和 .framework
* 动态库形式: 系统.framework   .dylib .tbd
* 系统的.framework是动态库,我们自己建立的是静态库
* .a是一个纯二进制文件. .framework还有资源文件
* .a不能直接使用,需要.h配合.  .framework可以直接使用
* .a + .h + .sourceFile = .framework
* 为什么使用静态库: 共享代码,程序模块化.三方sdk
* 注意: category 需设置other linker flags. 还可能没加载. 需要手动设置方法调用