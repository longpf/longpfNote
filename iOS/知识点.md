### 目录

* <a href="#layoutSubviews什么时候调用">layoutSubviews什么时候调用</a>
* <a href="#Xcode中的workspace、xcodeproj、target、schema的关系 ">Xcode中的workspace、xcodeproj、target、schema的关系 </a>
* <a href="#malloc和free">malloc和free</a>
* <a href="#静态库.a和.framework">静态库.a和.framework</a>


### 详情



<a id="layoutSubviews什么时候调用"></a>

<font color=#CD5C5C>
### layoutSubviews什么时候调用
</font>

```
init初始化不回触发
addSubView会触发
改变view的大小会触发,改变origin不回触发
改变子view的大小会触发,改变子view的origin不回触发
改变bounds会触发
旋转实测没触发(网上说触发),只是控制器self.view触发
setNeedsDisplay(使当前的layout无效,标记待刷新)会触发
```
*  如果调用layoutIfNeeded并且已被标记为待刷新,不回等到runloop结束,会立即刷新

<a id="Xcode中的workspace、xcodeproj、target、schema的关系 "></a>
<font color=#CD5C5C>
### Xcode中的workspace、xcodeproj、target、schema的关系 
</font>

[https://zhuanlan.zhihu.com/p/52130048](https://zhuanlan.zhihu.com/p/52130048)

* Target: 工程中最小可表一单元,每一个target对应一个编译输出,这个输出可以是一个链接库,一个可执行文件或者一个资源包.它定义了这个输出怎么被build的所有细节. 平时Build Settings，Build Phases 中配置的各种选项，大部分都是对应到指定的 target 的
	 * 编译选项,比如使用的编译器,目标平台,flag,头文件搜索路径等等
	 * 哪些源码或者资源文件会被编译打包,哪些静态库,动态库会被链接
	 * build时前置依赖,执行脚本文件
	 * build生成目标的签名, Capabilities等属性
* 每次我们在 Xcode 中 run/test/profile/analyze/archive 时，都必须指定一个 target
* 工程中的 targets 有时候会共享很多代码、资源，这些相似的 targets 可能对应同一个应用的不同版本，比如 iPad 版和 iPhone 版，或者针对不同市场的版本
* Project: 就是一个xcode工程,它管理这个工程下的targets集合以及他们的源码,引用的资源,framework等
* Project是管理资源的容器,单独无法被编译.只有有一个target.也可以对project进行配置,包括基本信息和编译选项,会应用到所有targets中, 如果单个target有自己的配置,会覆盖project配置
* Workspace: 当一个target被多个不同的项目依赖,或者project之间相互引用,这时需要把projects放到相同层级上来,管理他们的容器就是Workspac. 不参与任何编译链接过程
	 * xcode中projects,记录他们在finder中的引用位置
	 * 一些用户界面的自定义信息(窗口位置,顺兴,偏好等)
* Scheme: 针对一个指定的target,scheme定义了build这个target时使用的配置选项,执行的任务,环境参数等.可以理解为一个工作流或者蓝图.scheme中预设六个主要的工作流: Build,Run,Test,Profile,Ananlyze,Archive.
* Scheme 中最重要的一个配置是选择 target 的 build configuration，对每一个 project，会有两个默认的 build configuration：debug 和 release,可以自己新增
* 每个 configuration 对应了 build target 时不同的参数集，比如宏，编译器选项，bundle name 等等
* Scheme 还可以设置
	 * 环境变量（Environment Variables）
	 * runtime，内存管理，日志，帧率检测等调试选项(加载时间)
	 * App 执行时的系统语言、模拟的定位坐标、国家等环境参数
	 * 启动时设置给 UserDefaults 的参数

<a id="malloc和free"></a>
<font color=#CD5C5C>
### malloc和free
</font>

* 详细:[https://www.huaweicloud.com/articles/baea6198b9bbe8da4875c09f081edd21.html](https://www.huaweicloud.com/articles/baea6198b9bbe8da4875c09f081edd21.html)
* 申请内存后必须坚持是否分配成功(堆)
* 释放后最后置NULL指针
* 申请后最好强转类型,可以躲过一些编译检查
*  free释放的事指向的内存,指针没有释放,只不过指针指向的内容是未定义的,垃圾内存
*  大多数实现分配的存储空间比要求的要稍微大一些,额外的空间就管理信息(分配块的长度,下一个分配块的指针等待).一般用结构体存储

	```
	 struct mem_control_block { 
	 	int is_available; //一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记
     	int size; //这是实际空间的大小  
     	};
	```

<a id="静态库.a和.framework"></a>
<font color=#CD5C5C>
### 静态库.a和.framework
</font>

* 库: 共享代码的方式.一般分为静态库和动态库.
* 静态库: 编译的时候会直接拷贝一份到目标程序里,这段代码在目标程序里就不会改变了.好处没有外部依赖,直接可以运行,缺点增大目标程序体积.有多份冗余拷贝
* 动态库: 链接时不复制.运行时由系统加载到内存,工程序使用.系统只加载一次,多个程序共用.有点不影响目标程序体积.缺点: 性能上的损失,依赖外部环境. 自己开发的静态库还是动态库都要复制到目标程序,所以苹果又把这个交友embeded framework.
* 静态库形式: a.  和 .framework
* 动态库形式: 系统.framework   .dylib .tbd
* 系统的.framework是动态库,我们自己建立的是静态库
* .a是一个纯二进制文件. .framework还有资源文件
* .a不能直接使用,需要.h配合.  .framework可以直接使用
* .a + .h + .sourceFile = .framework
* 为什么使用静态库: 共享代码,程序模块化.三方sdk
* 注意: category 需设置other linker flags. 还可能没加载. 需要手动设置方法调用


<a id="异步渲染原理 && setNeedsDisplay"></a>
<font color=#CD5C5C>
### 异步渲染原理 && setNeedsDisplay
</font>

*  调用[UIView setNeedsDisplay]不回立马发送对应视图的绘制工作,调用后回调用同名方法 [view.layer setNeedsDisplay],并在view上标记为待刷新. 当runloop将要结束的时候才会调用[CALyer display]进入仕途真正绘制工作
*  setNeedsDisplay, setNeedsLayout都是异步执行
	 * setNeedsDisplay会自动调用drawRect,这样可以拿到UIGraphicsGetCurrentContext
	 * setNeedsLayout(会是当前layout无效)会默认调用layoutSubViews,当想调整子视图布局的时候调用setNeedsLayout
	 * layoutSubViews方便数据计算, drawRect方便视图绘制
*  异步绘制绘制
	* 自定义CALyer给view.
	* [CALyer display]的时候在子线程去绘制生成位图,绘制包括计算ctframer,ctline,ctrun,drawLine等
	* 将绘制好的位图,切到主线程复制给view.content
*  setNeedsLayout可能会多次被调用,所以异步绘制需要一个atomicInt自增来防止上一次无效的绘制. setNeedsLayout调用一次自增一次.在上一次异步绘制的开始,生成image,切主线程赋值layer.content的时候都要比对这个自增数,如果自增数变化,证明中间调用setNeedsLayout了,取消当前(上一次)处理流程