<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


* <a href="#05 数组 栈空间代码问题">05 数组 栈空间代码问题</a>
* <a href="#06 链表,LRU">06 链表,LRU</a>
* <a href="#08 栈">08 栈</a>
* <a href="#09 队列">09 队列</a>
* <a href="#10 递归">10 递归</a>
* <a href="#冒泡">冒泡</a>
* <a href="#插入">插入</a>
* <a href="#选择排序">选择排序</a>
* <a href="#希尔排序">希尔排序</a>
* <a href="#为什么选择插入排序而不是冒泡">为什么选择插入排序而不是冒泡</a>
* <a href="#归并">归并</a>
* <a href="#快排">快排</a>
* <a href="#桶排序">桶排序</a>
* <a href="#计数排序">计数排序</a>
* <a href="#基数排序">基数排序</a>
* <a href="#二分查找">二分查找</a>
* <a href="#17 跳表 为什么redis用跳表实现有序集合">17 跳表 为什么redis用跳表实现有序集合</a>
* <a href="#18&19 散列表">18&19 散列表</a>
* <a href="#20 为什么散列表和链表经常一起使用">20 为什么散列表和链表经常一起使用</a>
* <a href="#哈希算法">哈希算法</a>
* <a href="#23 二叉树基础 什么样的二叉树适合用数组来存储">23 二叉树基础 什么样的二叉树适合用数组来存储</a>






<a id="05 数组 栈空间代码问题"></a>

### 05 数组 栈空间代码问题

```cpp
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}

上面代码无限打印hello world. 
当i=3,a[i]地址就是i的地址.
因为i,arr是main函数的栈空间分配的.
从高到低是i,a[2],a[1],a[0] 所以访问a[i]的地址就是i的地址.
```

<a id="06 链表,LRU"></a>

### 06 链表,LRU

* 时间复杂度
	* 链表: 插入,删除O(1)  随机访问O(n)
	* 数组: 输入,删除O(n)  随机访问O(1)
* 数组优点: 简单易用,空间连续,访问高效
* 数组缺点: 大小固定,一经声明占用连续内存空间.内存不足是需要扩容,要将原来的数据拷贝到新的数组,非常耗时
* 链表和数组相比,更适合插入,删除频繁的场景.


<a id="08 栈"></a>

### 08 栈 

* 浏览器前进,后退   (两个栈)
* 表达式的求值  (数值栈+符号栈)
* 括号的匹配
* 为什么用栈来保存临时变量
	* 不一定非要用栈,只不过函数调用符合后进先出的特性
	* 从调用函数进入被调函数,对于数据变化的是作用域,只要能保证每进入一个新的函数都是一个新的作用域就可以.进入被调函数是,分配一段栈空间,函数结束后,栈顶复位,正好回到调用函数的作用域内.

<a id="09 队列"></a>

### 09 队列

* 先进先出.数组实现的为顺序队列,链表实现的是链式队列,还有循环队列
* 数组实现的队列,会有数据搬移的操作
* 循环队列实现重点: 队列为空和队列满了.需要浪费一个数据位,否则队空和队满都是head==tail

	```cpp
	class CircularQueue
	{
		private:
		string *items;
		int n = 0;
		int head = 0;
		int tail = 0;
		public:
		CircularQueue(int capacity){
			items = new string[capacity]{};
			n = capacity;
		};
		bool enqueue(string item){
			if ((tail+1) % n == head) return false;
			items[tail] = item;
			tail = (tail+1) % n;
			return true;
		}
		string dequeue(){
			if (head == tail) return NULL;
			string ret = items[head];
			head = (head + 1) % n;
			return ret; 
		}
		~CircularQueue(){
			if (items != NULL){
				delete[] items;
			}
		};
	};
	```
	
* java中 cas(Compare and Swap即比较并替换)无锁同步.ios中dispatch_once也用到这种cpu级别的无锁同步技术

<a id="10 递归"></a>

### 10 递归

* 递归需要满足的三个条件
	* 一个问题的解可以分解为几个子问题的解
	* 这个问题与子问题除了数据规模不同,求解思路完全一样
	* 存在递归终止条件
* 如何写递归代码
	* 找到如何将大问题分解为小问题的规律,并写出递推公式类似`f(n)=f(n-1)+f(n-2)`
	* 找到终止条件
	* 将公式和终止条件翻译成代码
* 要注意栈溢出
* 要注意重复计算,比如上面的公式f(3)可能被重复计算,可用散列表保存
* 笼统的讲,递归都可以写成迭代循环的方式.但是写成for或while栈空间过大问题还存在
* 避免出现环A-B-C-A
* 递归的调试
	* 打印日志发现,递归值
	* 结合条件断点进行调试
	

<a id="冒泡"></a>

### 冒泡

* 原地排序(空间复杂对为O(1)),稳定排序(相同的不会改变前后顺序)
* 最好O(n),最坏O\\((n^2)\\)
* 有序度:用有序对的个数来标示. 逆序度=满有序度-有序度.
* 一个排好的数组是满有序度,有序对个数为\\(C_n^2\\)=n*(n-1)/2
* 取中间的逆序对个数为n*(n-1)/4,则需要这么多次比较,平均复杂度为O\\((n^2)\\)



	```cpp
	void bubbleSort(int a[],int n){
		if (n<=1) return;
		for (int i = 0; i < n; ++i){
			// 提前退出的标志
			bool flag = false;
			for (int j = 0;j < n - i - i; ++j){
				// 交换
				if (a[j] > a[j+1]){ 
					int tmp = a[j];
					a[j] = a[j+1];
					a[j+1] = tmp;
					// 表示有数据的交换
					flag = true;
				}
			}
			// 如果没有数据交换说明对每个a[j+1]都大于a[j]
			if (!flag) break;
		}
	}	
	```
	
<a id="插入"></a>
	
	
### 插入

* 原地排序,稳定排序
* 最好O(n),在有序数组中,最坏O\\((n^2)\\)在倒叙中
* 平均复杂度是O\\((n^2)\\),因为插入一个数据的平均复杂度为O(n)

	```cpp
	void insertionSort(int a[],int n){
		if (n <= 1) return;
		
		for(int i = 1; i < n;i++){
			int value = a[i];
			int j = i - 1;
			for (;j>=0;j--){
				if (a[j] > value){
					// 数据移动
					a[j+1] = a[j];
				}else{
					break;
				}
			}
			a[j+1] = value;
		}
	}
	```
	
	
<a id="选择排序"></a>
	
### 选择排序

* 有点类似插入排序,区分已排序区间和未排序区间.
* 每次从未排序区间找到最小元素与已排序后面的第一个元素交换,这样就不是稳定的排序
* 找最小元素就对未排序元素的一次遍历
* 原地排序,最好,最坏,平均复杂度都为O\\((n^2)\\)


<a id="希尔排序"></a>

### 希尔排序

对插入排序的分区域优化

[https://zh.wikipedia.org/wiki/希尔排序](https://zh.wikipedia.org/wiki/希尔排序)


<a id="为什么选择插入排序而不是冒泡"></a>

### 为什么选择插入排序而不是冒泡

* 两个算法的复杂度都是O\\((n^2)\\)
* 不管怎么优化,冒泡交换次数都是一个固定值逆序度.
* 插入也一样移动次数也为逆序度
* 但交换操作比移动操作复杂.交换需要三个赋值操作,移动只需要一个

<a id="归并"></a>

### 归并

* 空间复杂度为O(n),稳定排序.
* 最好,最坏,平均时间复杂度都是O(nlogn)

	```
	T(1) = C； n=1 时，只需要常量级的执行时间，...
	T(n) = 2*T(n/2) + n； n>1
	
	T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......

	得到T(n) = 2^kT(n/2^k)+kn.当 T(n/2^k)=T(1) 时，
	也就是 n/2^k=1，我们得到k=log2n.将k代入的到T(n)=Cn+nlog2n.
	用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)
	```
	
<a id="快排"></a>

### 快排

* 快排和归并都要到了分治
	* 归并是由下到上,先处理子问题,然后在合并
	* 快排相反,先分区
* 空间复杂度为O(1),非稳定
* 时间大部分情况下为O(nlogn),只有在极端情况下为O\\((n^2)\\),分区不均匀的情况下
* 为什么快排比归并运用的广泛,归并空间复杂度O(n),n很大时候,消耗空间大,快排为原地排序,即使在极端下会为O\\((n^2)\\),但可通过选择合理的分区点避免,比如三点取中.


<a id="桶排序"></a>

### 桶排序

* 不是基于比较的,只分桶,桶之间有顺序
* 为什么时间复杂度是O(n)?

	```
	将n个数据放到m个桶中,每个桶中有k=n/m个元素
	每个桶中使用快排,为O(k*logk)
	m个桶就是O(m*k*logk)
	k = n/m,m接近n时,log(n/m)是一个非常小的常量.
	这时桶排序的时间复杂度接近O(n)
	```
* 桶排序要求的条件非常苛刻.
	* 数据需要很容易划分成m个桶
	* 桶与桶之前有天然的大小顺序
	* 各桶之间分布均匀

* 桶排序比较适合用在外部排序中,就是存储在外部磁盘中,数据比较大
	* 10GB订单排序
	* 100万用户按年龄排序,可以分成120个桶


<a id="计数排序"></a>
	
### 计数排序

* 可以认为是桶排序的一种,当桶的范围并不大时,可以考虑,O(n)
* 对50万考生按分数排序,总分900分,就可以分成901个桶
* 排序的只能是非负整数排序,如果是其他类型要转成非负整数
	* 小数点后一位,乘以10变成整数
	* [-1000,1000],每个数加上1000

	```cpp
	// 桶排序,计数排序
	// a 是数组，n 是数组大小。假设数组中存储的都是非负整数
	void countingSort(int a[],int n){
		if (n<=1) return ;
		    
		// 查找数组中数据的范围
		int max = a[0];
		for (int i = 1; i < n; i++) {
		    if (max < a[i]){
		        max = a[i];
		    }
		}
		    
		// 申请一个计数数组c,下标大小[0,max]
		int *c = new int[max+1]{};
		    
		// 计算每个元素的个数,放入c中
		for (int i=0; i<n; i++) {
		    c[a[i]] ++;
		}
		    
		// 依次累加
		for (int i = 1; i <= max; i++) {
		    c[i] = c[i-1]+c[i];
		}
		    
		//临时数组r,存储排序之后的结果
		int *r = new int[n]{};
		// 计算排序的关键步骤
		for (int i = n-1; i>=0; i--) {
		    int index = c[a[i]] - 1;
		    r[index] = a[i];
		    c[a[i]]--;
		}
		    
		// 将结果拷贝给a数组
		for (int i=0; i<n; i++) {
		    a[i] = r[i];
		}
		    
		// 收尾工作
		delete [] r;
		delete [] c;
	}
	```
	
<a id="基数排序"></a>
	
	
### 基数排序

* 基数排序对数据有要求的
	* 可以分割出独立的'位'来比较,
	* 而且位之间又递进的关系,如果a数据的高位比b数据大,那剩下的位就不用比较了.
	* 每一位的数据范围不能太大,要可以用线性排序法来排序,否在基数排序无法做到O(n)
* 10万个手机号排序,可以低位到高位进行11次通排序
* 牛津字典单词排序
	
<a id="二分查找"></a>


### 二分查找

* O(logn)的查找速度 很快,
	
	```
	被查找的区间大小为 n, n/2, n/4, n/8 ..., n/2^k
	等比数列,其中n/2^k=1,k的值就是总共缩小的次数,
	经过k次的缩小区间
	所以复杂度为O(k), n/2^k=1,k = log2n
	所以复杂度为O(logn)
	```
	
* mid = (low+high) /2 如果low和high比较大,为防止溢出可写成mid =low + (high-low)/2
* 必须是数组才能用二分,链表的话没有索引,需要遍历
* 数据量小不适合不如直接遍历来的快,数据量过大也不行,因为为数组需要在内存中有连续的大内存
* 12万ip查找归属地,可以用最后一个小于等于给定值的元素的变种

	```cpp
	// 标准
	int bsearch(int a[],int n,int value){
		int low = 0;
		int high = n-1;
		while(low<=high){
			int mid = (low+high)/2;
			if (a[mid]==value){
				return mid;
			}else if (a[mid]<value){
				low = mid + 1;
			}else {
				high = mid -1;
			}
		}
		return -1;
	}
	
	// 下面是二分法 变种
	
	// 查找第一个等于给定值的元素
	int bsearch(int[] a, int n, int value) {
	  int low = 0;
	  int high = n - 1;
	  while (low <= high) {
	    int mid =  low + ((high - low) >> 1);
	    if (a[mid] > value) {
	      high = mid - 1;
	    } else if (a[mid] < value) {
	      low = mid + 1;
	    } else {
	      if ((mid == 0) || (a[mid - 1] != value)) return mid;
	      else high = mid - 1;
	    }
	  }
	  return -1;
	}
	// 最后一个等于给定值的元素
	int bsearch(int[] a, int n, int value) {
	  int low = 0;
	  int high = n - 1;
	  while (low <= high) {
	    int mid =  low + ((high - low) >> 1);
	    if (a[mid] > value) {
	      high = mid - 1;
	    } else if (a[mid] < value) {
	      low = mid + 1;
	    } else {
	      if ((mid == n - 1) || (a[mid + 1] != value)) return mid;
	      else low = mid + 1;
	    }
	  }
	  return -1;
	}
	// 第一个大于等于给定值的元素
	int bsearch(int[] a, int n, int value) {
	  int low = 0;
	  int high = n - 1;
	  while (low <= high) {
	    int mid =  low + ((high - low) >> 1);
	    if (a[mid] >= value) {
	      if ((mid == 0) || (a[mid - 1] < value)) return mid;
	      else high = mid - 1;
	    } else {
	      low = mid + 1;
	    }
	  }
	  return -1;
	}
	// 最后一个小于等于给定值的元素
	int bsearch7(int[] a, int n, int value) {
	  int low = 0;
	  int high = n - 1;
	  while (low <= high) {
	    int mid =  low + ((high - low) >> 1);
	    if (a[mid] > value) {
	      high = mid - 1;
	    } else {
	      if ((mid == n - 1) || (a[mid + 1] > value)) return mid;
	      else low = mid + 1;
	    }
	  }
	  return -1;
	}
	```
	
<a id="17 跳表 为什么redis用跳表实现有序集合"></a>
	
### 17 跳表 为什么redis用跳表实现有序集合

* 单纯的链表不支持二分法,改造后的数据结构跳表可实现类似二分法
* 动态数据结构,快速的插入,删除,查找,写起来不复杂.甚至可以替代红黑树
* 为链表加多级索引的结构就是跳表.多级,比如原始元素为n个,没2个去一个索引,则一级索引就有n/2个索引,二级就有4/n个索引,...一直到最上层的索引为2个
* 查找速度为O(logn)

	```
	假设每两个取一个索引
	一级索引为n/2,二级索引为n/4,三级为n/8
	k级索引为n/2^k
	假设有h级的所有,最高级为2个结点.则 n/(2^h) = 2,h = log2n-1
	如果包含原始链表这一层,整个跳表的高度为log2n层
	如果每一层遍历m个结点,那么查询的复杂度就为O(m*logn)
	m在这里,每一层最多为3
	```
	
* 空间问题 O(n),实际开发中,结点存的大多为对象,索引为指针,所以索引的空间基本可以忽略

	```
	如果每两个结点取一个索引的话
	n/2+n/4+n/8+..+8+4+2=n-2,等比数列
	
	如果每两个结点取一个索引的话
	n/3+n/9+n/27+...+9+3+1 = n/2
	```
	
* 插入的为O(logn).先找到O(long),在插入O(1)
* 删除也是O(logn),需要先找到前驱结点,如果索引中有要删除的结点,该索引也要被删除
* 跳表索引动态更新,通过随机函数来维护索引与原始链表大小之间的平衡.比如插入数据6的结点,随机到的数位k=2,那从第一级索引到第二级索引都要加上6这个结点的索引

<a id="18&19 散列表"></a>

### 18&19 散列表

* 对数组的扩展
* 散列冲突解决	
	* 开放寻址法
		* 线性探测,如果被占用就探测下一个,到了数组末尾的话就跳到第一个位置探测
		* 二次探测,第一次为hash(key)+0,第二次为hash(key)+1,第三次为hash(key)+2^2..
		* 双重散列,采用一组散列函数,如果hash1(key)得到的位置被占用则使用hash2(key)..
		* 装载因子 = 填入表中的个数/散列表的长度
		* 删除数据时,需要标记该位置是删除状态,而不是空的状态
	* 链表法
		* 存储大对象,大对象下链表的指针消耗可忽略
* 如何选择解决冲突的方法
	* 开发寻址法: 当数据量比较小,装载因子小,Java 中的ThreadLocalMap
	* 链表法: 存储大对象,大数据量的散列表,更灵活,更多的优化策略,比如将链表替换为红黑树,跳表等
* word中的单词检查,将20万个常用单词读入内存,假设每个单词的平均长度为10,那么平均一个单词为10字节,20万个单词为20M.当输入单词后去表中查找,找到就为正确
* 10万条URL访问日志,按照访问次数排序
	* 1. 遍历存入散列表,key为URL,value为次数
	* 2. 对次数进行排序,次数不大的话用桶排序,大的话用快排
* 两个字符串数组,每个数组大约有10万个字符串,找出相同字符串
	* 1. 将数组1中的字符串全部放入散列表,key为字符串,value为次数
	* 2. 遍历数组2,将每个字符串从散列表中查找,如果字符串对应的次数大于1,则为重复的字符串
* 动态扩容: 一般当装载因子大于一个阈值时,需扩容,一般扩展为原来的2倍.原散列表的内容需要复制到新的散列表中.
	* 为了避免类似1GB的大数据量复制.一般分批复制
	* 每插入一次复制原散列表中的一条数据
	* 查找时候先查找新散列表中,如果没有查找原散列表中
* 工业级的散列表
	* 1. 如果涉及散列函数. 应做到尽量的均匀
	* 2. 如何根据装载因子动态扩容.
	* 3. 冲突解决办法

<a id="20 为什么散列表和链表经常一起使用"></a>

### 20 为什么散列表和链表经常一起使用

* LRU缓存淘汰算法
	* 散列表和双向链表共同协作
	* 散列表的数组中,每个元素为一个链表
	* 链表的每个结点由prev,next,data,hnext组成
		* prev是双向链表的前驱指针
		* next是双向链表的后继指针
		* data是结点的数据
		* hnext是散列表解决冲突中的拉链指针
	* 查找数据: 通过散列表近似O(1)的时间复杂度找到,找到到后还需要将它移动到双向链表的尾部.移动的时候,只是改变prev,next的指向,数据位置并没有改变
	* 删除一个数据: O(1)找到结点,根据prev找到前驱结点
	* 添加一个数据: 如果在散列表中存在,那么移动到链表尾部,并且替换数据.如果不存在的话,先看缓存满了吗,满了,就删除双向链表头部的结点,没满的话就放到双向链表的尾部
* java中的LinkedHashMap也是这种的实现方式.linked指的是双向链表
* YYCache中的YYMemoryCache(内存缓存)用到LRU,结合散列表和双向链表的数据结构


<a id="哈希算法"></a>

### 哈希算法

* 哈希算法: 将任意长度的二进制串映射为固定长度的二进制串.
	* 从哈希值不能反向推到出原始数据
	* 即使原始数据变化1bit,哈希值也大不相同
	* 散列冲突很小,哈希值相同的概率非常小
	* 哈希算法尽量高效.
* 应用: 
	* 安全加密,密码加密,MD5,SHA
	* 唯一标识,以前百度云的秒传,
	* 数据校验, BT下载,基于P2P协议,一个电影被分成很多块从不同的寄主下载,下载后比较是否被篡改
	* 散列函数,应尽量保持均匀和高效
* 2011年CSDN脱库,导致600万注册邮箱和明文密码泄露.密码应用SHA加密(MD5号称已被破解),再使用一个盐(salt)跟用户密码组合在一起.
* 区块链: 区块链是一块块区块组成的,每个区块由区块头和区块体组成.
	* 区块头中保存着自己的区块体和上一个区块头的哈希值
	* 这种链式关系和哈希值的唯一性,只要区块链上任意一个区块被修改过,后面区块保存的哈希值就不对了
	* 区块链用的SHA256哈希算法,计算非常耗时,篡改一个,就必须重新计算该区块后面的所有区块的哈希值,短时间内几乎不可能做到

#### 其他应用

* 负载均衡,将用户的请求尽可能均匀分配到不同的缓存服务器
	* 常见的负载均衡算法有很多,比如轮询,加权轮询,随机
	* 如何实现一个粘滞的负载均衡算法,同一个会话中的所有请求路由到同一个服务器上?
		* 最直接的维护会话id或者ip和服务器的表
		* 但是客户端可能很多,映射表可能很大
		* 客户端的上下线,服务器的扩容,缩容会导致映射失效,维护成本大
		* 可以借助哈希算法,将会话id货值ip的哈希值,对服务器列表取余,得到的就是对应的服务器编号
* 数据分片: 1T的日志文件,统计搜索关键词出现的次数
	* 需要多个机器
	* 遍历,每个关键词取哈希值后,再对机器数量取模得到的值就是改关键词该被分配的机器
	* 这样同一个词就会被分配到同一个机器上
	* 每个机器会分别计算关键词的次数
	* 这也是mapReduce的基本设计思想
* 海量的图片分片也可以参考上面的分片
* 分布式存储: 现在互联网的海量数据,海量用户.为了提高读取,写入能力,一般采用分布式的方式来存储数据,比如分布式缓存.海量数据的存储,要缓存在多个机器上.
	* 如果数据量增加,需要添加服务器缓存的话,按照上面的所讲,所有缓存服务器查找的取模计算就失效了,会直接去数据库查找,这样会压垮数据库
	* 这时候需要用到一致性哈希算法
	* 图解[https://www.sohu.com/a/158141377_479559](https://www.sohu.com/a/158141377_479559)

<a id="23 二叉树基础 什么样的二叉树适合用数组来存储"></a>

### 23 二叉树基础 什么样的二叉树适合用数组来存储

* 满二叉树: 叶子节点全都在底层,除了叶子节点之外,每个节点都有左右两个节点
* 完全二叉树: 叶子节点都在最底两层,最后一层的叶子节点都靠左排列,并且除了最后一层,其他层的节点个数都要达到最大
* 二叉树的储存:
	* 基于指针或者引用的二叉链式存储法
	
		![](1.jpg)
	* 基于数组的顺序存储法,我们把根节点储存在下标i=1的位置,那左子结点存储在下标`2*i=2`的位置,右子节点存储在`2*i+1=3`的位置.依次类推.反过来`i/2`的位置就是父节点.不过要浪费一个1位置的空间,对于完全二叉树,如下面
	
		![](2.jpg)
	* 非完全二叉树要浪费更多的空间

		![](3.jpg)		
		
* 前,中,后序遍历,见之前的[atoffer](https://github.com/longpf/AtOffer#二叉树的前中后序遍历)
* 给定一组数据比如1,3,5,6,9,10,可以构建多少种二叉树?
	
	```
	n!种
	
	```
		

### 24 二叉树基础 有了如此高效的散列表,为什么还需要二叉树

#### 二叉查找树

* 树中任意一个节点,其左子树中的每个节点的值,都要小于这个节点的值,而右子树的值都大于这个节点的值
* 插入,删除,查找跟数的高度正比
* 为什么还要用二叉查找树?
	* 散列表中的数据都是无序存储的,如果要输出有序的数据,需要先进行排序,而对于二叉查找树来说,我们只需要中序遍历,就可以在O(n)的时间复杂度内输出
	* 散列表扩容耗时很多,而且遇到散列冲突时,性能不稳定,在常用的平衡二叉查找树的性能可以稳定在O(logn)
	* 尽管散列表的查找操作时间复杂度是常量级,但是哈希冲突的存在,这个常量不一定比logn小
	* 散列表相对复杂,要考虑设计,冲突解决,扩容等.平衡二叉树只需要考虑平衡,而且这个问题的解决方案比较成熟
	* 因为装载因子不能太大,尤其开放寻址法,所以要浪费更多的空间

	
### 25 红黑树(上) 为什么工程中都用红黑树这种二叉树

* 平衡二叉树: 严格的定义是这样的,二叉树中任意一个结点的左右字数的高度相差不能大于1.完全二叉树,满二叉树都是平衡二叉树
* AVL数满足严格的平衡二叉树
* 平衡二叉查找树中的'平衡'的意思,其实是让整棵树左右看起来比较对称,比较平衡,不要出现左子树很高,右子树很矮的情况,这样就能保证整棵树相对低,插入,删除,查找等操作的效率高一些
* 红黑树: 不是一种严格的平衡二叉查找树
	* 根结点是黑色的
	* 每个叶子节点都是黑色的空结点(NIL),也就是说叶子节点不储存数据,主要为了简化红黑树的代码实现
	* 任何相邻结点都不能同时为红色,也就是说红色结点被黑色结点隔开
	* 每个节点,从该节点到达其可达叶子节点的所有路径,都包含相同数目的黑色结点
* 红黑树的高度简单说明,可以去掉红色结点,黑色结点的高度小于log2n,所以原红黑树的高度小于2log2n,所以插入,删除,查找都是O(logn)
* 为什么用红黑树?近似平衡,解决普通二叉查找树在数据更新的过程中,复杂度退化的问题.复杂度都是O(n),但是实现比较复杂,可以考虑用跳表替代他


### 26 红黑树(下) 
* 红黑树在插入删除的时候会打破定义的第三第四条定义
* 左旋和右旋
	
	![](4.jpg)
	
* 具体操作要看原文[https://time.geekbang.org/column/article/68976#previewimg](https://time.geekbang.org/column/article/68976#previewimg)


### 28 堆和堆排序 为什么说堆排序没有快速排序快

* 完全二叉树从n/2+1开始都是叶子节点
* 堆排序分为建堆和排序,建堆为O(n),排序为O(nlogn)所以总的时间为O(nlogn)
* 与快排比较:
	* 快排的数据交换次数不会比逆序度多,堆排建堆的过程会先打乱原有的有序度

```cpp
// 大顶堆
class Heap{
	int *a; // 数组,从下标1开始处处数据
	int n; 	// 堆可以存储的最大个数
	int count; // 堆中已经存储的数据个数
public:
	Heap(int capacity){
		a = new int[capacity+1];
		n = capacity;
		count = 0;
	}

	void insert(int data){
		if (count >= n) return;
		++count;
		a[count] = data;
		int i = count;
		// 自下往上堆化
		while (i/2 > 0 && a[i] > a[i/2]){
			swap(a[i],a[i/2]);
			i = i/2;
		}
	}
	// 自上往下堆化
	void heapify(int a[],int n,int i){
		while(1){
			int maxPos = i;
			if (i*2<=n && a[i]<a[i*2]) maxPos = i*2;
			if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
			if (maxPos==i)  break;
			swap(a[i],a[maxPos]);
			i = maxPos;
		}
	}

	int removeMax(){
		if (count ==0) return -1;
		return a[1];
		a[1] = a[count];
		--count;
		heapify(a,count,1);
	}

	void buildHeap(int a[],int n){
		for (int i=n/2;i>=1;--i){
			heapify(a,n,i);
		}
	}

	void sort(int a[],int n){
		buildHeap(a,n);
		int k = n;
		while (k>1){
			swap(a[1],a[k]);
			--k;
			heapify(a,k,1);
		}
	}
};
```

