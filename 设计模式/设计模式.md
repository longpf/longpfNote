[https://www.runoob.com/design-pattern/strategy-pattern.html](https://www.runoob.com/design-pattern/strategy-pattern.html)

**创造型模式:**

* <a href="#工厂模式">工厂模式</a>
* <a href="#抽象工厂模式">抽象工厂模式</a>
* <a href="#单例模式">单例模式</a>
* <a href="#建造者模式">建造者模式</a>
* <a href="#原型模式">原型模式</a>

**结构型模式:**

* <a href="#适配器模式">适配器模式</a>
* <a href="#享元模式">享元模式</a>
* <a href="#桥接模式">桥接模式</a>
* <a href="#过滤模式">过滤模式</a>
* <a href="#装配器模式">装配器模式</a>
* <a href="#外观模式">外观模式 --- 音频插件结构</a>
* <a href="#主从模式">主从模式 --- 音频插件结构</a>
* <a href="#代理模式">代理模式 --- 音频插件结构</a>



**行为模式:**

* <a href="#责任者链模式">责任者链模式</a>
* <a href="#命令模式">命令模式</a>
* <a href="#解释器模式">解释器模式</a>
* <a href="#中介者模式">中介者模式</a>
* <a href="#观察者模式">观察者模式</a>
* <a href="#策略模式">策略模式</a>
* <a href="#访问者模式">访问者模式</a>


##详情

<a id="外观模式"></a>

### 外观模式

* 外观模式, 隐藏系统的复杂性, 并向客户端(外界调用方)提供一个可以访问的系统接口.这种类型的设计属于结构型模式,它向现有的系统添加一个接口,来隐藏系统的复杂性.

* 主要解决: 降低访问复杂系统的内部子系统的复杂度, 简化客户端之间的接口
* 优点: 减少系统的相互依赖, 提高灵活性, 提高安全性
* 缺点: 不符合开闭原则,如果要改东西很麻烦,继承重写都不合适

**音频插件化**

* 多模板插件化对外隐藏了复杂了模板判断,数据处理,玩法展示等逻辑
* 只在主件提供可用接口供外界使用,如果需要访问当前模板状态,需要通过主件
* 缺点: 不符合开闭原则, 调用方如果需要一个新调用, 需要主件提供接口,增加主件代理协议,在子件里去实现. 增加了调用过程以及实现复杂度


<a id="主从模式"></a>
### 主从模式

* 主从模式,多用于服务端redis上,是指 将一台redis服务器的数据,复制到其他的redis服务器
* 前着称为主节点(master),后者称为从节点(slave).数据的复制是单向的,只能由主节点到从节点
* 主节点具备读/写能力, 从节点只具备读的能力
* 优点: 主节点宕机,从节点可以晋升为主节点. 扩展主节点的读能力
* 缺点: 主节点的写能力,存储能力受限于单机

**音频插件系统中**

* 主件相当于主节点, 子件相当于从节点
* 子件通过上下文可以拿到数据,存于子件,模板间数据访问可通过子件的保存的数据
* 子件如果想要修改数据,需要通过主件操作, 主件提供主件能力协议.供子件使用


## 创建型模式

<a id="工厂模式"></a>
### 工厂模式

提供一种创建对象的最佳方式.在创建时不会对客户端(调用方暴露创建逻辑),并通过一个公用的接口来创建对象

* 主要解决接口选择问题,明确的计划不同条件下创建不同的实例
* 优点: 调用者想创建一个对象,只需要知其名就可以. 扩展性高,想增加一个产品,只需要增加一个工厂. 屏蔽产品的具体实现
* 缺点: 没增加一个产品,就需要一个工厂,增加类的数量, 一定程度上增加复杂度和依赖关系

<a id ="抽象工厂模式"></a>
### 抽象工厂模式

围绕一个超级工厂创建其他工厂.该超级工厂又称为其他工厂的工厂. 

在抽象工厂中, 接口是负责创建一个相关对象的工厂,不需要显示指定他们的类.每个生成的工厂都能按照工厂模式提供对象

* 使用场景: 系统的产品多于一个,产品族, 而系统只消费其中的某一族产品
* 优点: 当一个产品族中有多个对象被设计成一起工作时,它能保证客户端始终只是用同一个产品族中的对象
* 缺点:扩展困难. 要增加一个系列的某一个产品,既要在抽象的creator中加代码,又要在具体的工厂里面加代码

<a id="单例模式"></a>
### 单例模式

提供一种创建对象的最佳方式. 涉及的类负责创建自己的对象,同时确保只有单个对象被创建, 唯一访问其对象的方式

* 单例类只能有一个实例, 必须类自己创建, 必须给其他对象提供这个实例
* 优点: 减少开销,减少频繁创建,共享数据
* 缺点: 不能继承, 常驻内存

<a id="建造者模式"></a>
### 建造者模式

使用多个简单的对象,一步步构建成一个复杂的对象.Builder类独立于其他对象

* 优点: 建造者独立,易扩展, 便于控制细节风险
* 缺点: 内部复杂,可能造成Builder类很多

<a id="原型模式"></a>
### 原型模式

利用已有的一个原型对象，快速地生成和原型对象一样的实例。

* 优点: 性能提高,避免构造函数的约束
* 缺点: 需要配置拷贝方法, 对于复杂的旧类比较难


## 结构型模式

<a id="适配器模式"></a>
### 适配器模式


这种模式设计一个单一的类,结合两个独立接口,达到兼容. 将一个类的接口转换成客户希望的另一个接口. 比如 读卡器就是内存卡和笔记本之间的适配器

* 优点: 让没有关联的类一起运行.提高类的复用,更灵活
* 确定: 增加复杂性, 看似调用A,实则调用B

<a id="享元模式"></a>
### 享元模式

享元模式能够解决重复对象的内存浪费问题, 当系统中有大量相似对象,需要缓冲池时,不需要总是创建对象,可以从缓冲中拿. 这样可以降低系统内存,同时提高效率

* 对象信息一般分为两部分: 内部状态(不随着环境变化的),外部状态(随着环境变化的)
* 优点: 减少内存
* 缺点: 提高的系统的复杂度

<a id="桥接模式"></a>
### 桥接模式

将抽象部分与实现部分分离,使他们可以独立的变化, 系统实现可能有多个角度分类,每个角度都有可能变化 ,把多个角度分类,让他们独立变化,减少耦合.

* 优点: 抽象和实现分离, 扩展能力好
* 缺点: 增加系统设计难度,抽象层要设计好

<a id="过滤模式"></a>
### 过滤模式

允许开发人员使用不同的标准来过滤一组对象


<a id ="装配器模式"></a>

### 装配器模式

允许向一个现有的对象添加新的功能,同时又不改变其结构,

* 优点: 装饰类和被装饰类可以独立发展,不耦合
* 多层装饰比较复杂


<a id="代理模式"></a>
#### 代理模式

一个类代表另一个类的功能,

* 优点: 职责清晰, 高扩展性
* 缺点: 调用链边长, 需要额外操作



## 行为模式

<a id="责任者链模式"></a>
### 责任者链模式

为请求创建一个接受者链.如果一个对象不能处理该请求,那么他会把请求传给下一个接受者, 有点像OC里面的手势, 有备用处理手势

* 优点: 将发送者与接受者解耦
* 缺点: 接受者不一定存在, 可能造成循环

<a id="命令模式"></a>
### 命令模式

一种数据驱动的模式.将命令传给调用方,调用方寻找可以处理该命令的对象. 场景: 一个开始按钮, 

<a id="解释器模式"></a>
### 解释器模式


这种模式实现一个表达式接口, 该接口解释一个特定的上下文. 比如SQL解析,符号处理引擎


* 优点: 扩展性好, 灵活,
* 缺点: 利用场景少, 复杂的解释比较难维护

<a id="中介者模式"></a>
### 中介者模式

用来降低多个对象和类之间的通信复杂性. 这种模式提供一个中介类,该类处理不同类之间的通信, 解决对象之前的存在的大量关联关系


* 优点: 降低复杂度,将一对多,转化为一对一
* 缺点: 中介者会庞大,

<id ="观察者模式"></a>
### 观察者模式

当一个对象被修改时，则会自动通知依赖它的对象

* 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制
* 缺点: 多个观察者,效率低. 可能存在循环依赖

<a id="策略模式"></a>
### 策略模式

策略模式指的是定义一系列的算法，并且把它们封装起来，但是策略模式不仅仅只封装算法，我们还可以对用来封装一系列的业务规则.在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护.

* 优点: 算法可以自由切换,避免多重判断,
* 缺点: 策略类会增多

<a id="访问者模式"></a>
### 访问者模式

封装一些作用于某种数据结构中的各元素的操作,它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作

* 对象结构比较稳定,但经常需要在此对象进行很多不同的并且不相关的操作
* 需要对一个对象结构中的对象进行很多不同的操作,避免这些操作污染对象类


## 6大原则

[https://www.jianshu.com/p/3f91776c3672](https://www.jianshu.com/p/3f91776c3672)

* 单一职责原则告诉我们实现类要职责单一；
* 里氏替换原则告诉我们不要破坏继承体系；子类方法不能影响父类
* 依赖倒置原则告诉我们要面向接口编程；
* 接口隔离原则告诉我们在设计接口的时候要精简单一；
* 迪米特法则告诉我们要降低耦合；
* 而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。























